---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
  pdf: default
execute:
  echo: false
  eval: true
  include: true
---

# üé≤ Simulation Challenge - Monte Carlo Analysis

## Challenge Overview

**Your Mission:** Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called "simulationChallenge."



## Expected Value Analysis Answers üìä

Let's work through the expected value analysis questions step by step:

### Question 1: Expected Value After One Coin Flip

For the original game, after one coin flip:
- **Heads (50% probability):** Account becomes $1,000 √ó 1.5 = $1,500
- **Tails (50% probability):** Account becomes $1,000 √ó 0.6 = $600

**Expected Value = 0.5 √ó $1,500 + 0.5 √ó $600 = $750 + $300 = $1,050**

### Question 2: Expectation vs. Reality

The expected value is **positive** ($1,050 > $1,000), which suggests the game should be profitable on average. However, this is misleading because:

- The expected value calculation assumes you can play the game many times
- In reality, you only get to play once (until age 55)
- The multiplicative nature of the game creates extreme outcomes over time

### Question 3: Single Simulation Analysis

A single simulation would show one possible path of your account balance over time. You might see:
- **Lucky path:** Consistent heads leading to exponential growth
- **Unlucky path:** Consistent tails leading to rapid decline
- **Mixed path:** Alternating results with volatile swings

**Are you happy?** Probably not, because the single path is highly unpredictable and could end up much lower than $1,000.

```{r}
#| label: single-simulation-plot-r
#| fig-cap: Single simulation showing account balance over time (R)
#| echo: false
#| include: true
#| eval: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

set.seed(42)

initial_balance <- 1000
n_periods <- 35

simulate_investment_path <- function(initial, periods) {
  balance <- initial
  path <- numeric(length = periods + 1)
  path[1] <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance * 1.5
    } else {
      balance <- balance * 0.6
    }
    path[i + 1] <- balance
  }
  path
}

time_series_data <- tibble(
  year = 0:n_periods,
  balance = simulate_investment_path(initial_balance, n_periods)
)

ggplot(time_series_data, aes(x = year, y = balance)) +
  geom_line(color = "darkblue", linewidth = 1) +
  geom_point(color = "darkblue", size = 1.5) +
  geom_hline(yintercept = initial_balance, linetype = "dashed", color = "red", linewidth = 0.8) +
  scale_y_log10(labels = scales::dollar_format()) +
  labs(
    title = "Single Investment Simulation Path",
    subtitle = "Account Balance Over Time (Ages 20 to 55)",
    x = "Years",
    y = "Account Balance ($)"
  ) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold"))

tail_value <- tail(time_series_data$balance, 1)
cat(sprintf("Final balance: $%s\n", scales::comma(round(tail_value, 2))))
cat(sprintf("Return: %.1f%%\n", (tail_value / initial_balance - 1) * 100))
```

### Question 4: Multiple Simulations (100 runs)

With 100 simulations, you'd see a distribution of final account balances at age 55. The results would likely show:
- **Most outcomes:** Very low balances (close to $0)
- **Few outcomes:** Extremely high balances (millions)
- **Average:** Still around $1,050, but this is misleading

**Are you happy?** Probably not, because most people would end up with very little money.

```{r}
#| label: multiple-simulations-plot-r
#| fig-cap: Distribution of final account balances from 100 simulations (R)
#| echo: false
#| include: true
#| eval: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

set.seed(123)

initial_balance <- 1000
n_periods <- 35
n_sims <- 100

simulate_final_balance <- function(initial, periods) {
  balance <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance * 1.5
    } else {
      balance <- balance * 0.6
    }
  }
  balance
}

final_balances <- replicate(n_sims, simulate_final_balance(initial_balance, n_periods))

distribution_data <- tibble(
  sim_num = 1:n_sims,
  final_balance = final_balances
)

ggplot(distribution_data, aes(x = final_balance)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.75, color = "black") +
  geom_vline(xintercept = initial_balance, color = "red", linetype = "dashed", linewidth = 0.9) +
  geom_vline(xintercept = mean(distribution_data$final_balance), color = "orange", linewidth = 0.9) +
  scale_x_log10(labels = scales::dollar_format()) +
  labs(
    title = "Distribution of Final Account Balances",
    subtitle = "100 Simulations, 35 Years Each",
    x = "Final Balance ($)",
    y = "Frequency"
  ) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold"))

mean_balance <- mean(distribution_data$final_balance)
median_balance <- median(distribution_data$final_balance)
prob_above_initial <- mean(distribution_data$final_balance > initial_balance)
prob_above_10000 <- mean(distribution_data$final_balance > 10000)

cat(sprintf("Mean final balance: $%s\n", scales::comma(round(mean_balance, 2))))
cat(sprintf("Median final balance: $%s\n", scales::comma(round(median_balance, 2))))
cat(sprintf("Probability above $1,000: %.1f%%\n", prob_above_initial * 100))
cat(sprintf("Probability above $10,000: %.1f%%\n", prob_above_10000 * 100))
```

### Question 5: Probability Analysis

Based on 100 simulations, the probability that your account balance will be greater than $1,000 at age 55 is likely around **20-30%**. This means you have a 70-80% chance of ending up with less than your initial $1,000.

### Question 6: Strategy Comparison

For the modified strategy (betting 50% of account each time):
- The probability of ending up with more than $10,000 at age 55 would be even **lower** than the original game
- This is because the modified strategy is more conservative (smaller bets) but still has the same unfavorable expected value per bet
- The original game's higher volatility actually gives you a better chance of extreme outcomes (both positive and negative)

```{r}
#| label: strategy-comparison-plot-r
#| fig-cap: Comparison of original vs modified strategies (R)
#| echo: false
#| include: true
#| eval: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

set.seed(456)

initial_balance <- 1000
n_periods <- 35
n_sims <- 100

# Original strategy: bet entire account
simulate_original_strategy <- function(initial, periods) {
  balance <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance * 1.5
    } else {
      balance <- balance * 0.6
    }
  }
  balance
}

# Modified strategy: bet 50% of account each time
simulate_modified_strategy <- function(initial, periods) {
  balance <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    bet_amount <- balance * 0.5
    if (coin_flip == 1) {
      balance <- balance - bet_amount + (bet_amount * 1.5)
    } else {
      balance <- balance - bet_amount + (bet_amount * 0.6)
    }
  }
  balance
}

original_balances <- replicate(n_sims, simulate_original_strategy(initial_balance, n_periods))
modified_balances <- replicate(n_sims, simulate_modified_strategy(initial_balance, n_periods))

comparison_df <- tibble(
  strategy = rep(c("Original", "Modified"), each = n_sims),
  final_balance = c(original_balances, modified_balances)
)

library(scales)

ggplot(comparison_df, aes(x = final_balance)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
  geom_vline(xintercept = 1000, color = "red", linetype = "dashed", linewidth = 0.9) +
  geom_vline(xintercept = 10000, color = "darkgreen", linetype = "dotted", linewidth = 0.9) +
  scale_x_log10(labels = dollar_format()) +
  labs(
    title = "Strategy Comparison: Final Account Balances",
    subtitle = "100 Simulations Each, 35 Years",
    x = "Final Balance ($)",
    y = "Frequency"
  ) +
  facet_wrap(~ strategy, nrow = 1, scales = "free_y") +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold"))

orig_prob_above_1000 <- mean(original_balances > 1000)
orig_prob_above_10000 <- mean(original_balances > 10000)
mod_prob_above_1000 <- mean(modified_balances > 1000)
mod_prob_above_10000 <- mean(modified_balances > 10000)

cat("=== STRATEGY COMPARISON RESULTS (R) ===\n")
cat(sprintf("Original Strategy: P(> $1,000) = %.1f%%, P(> $10,000) = %.1f%%\n",
            orig_prob_above_1000 * 100, orig_prob_above_10000 * 100))
cat(sprintf("Modified Strategy: P(> $1,000) = %.1f%%, P(> $10,000) = %.1f%%\n",
            mod_prob_above_1000 * 100, mod_prob_above_10000 * 100))
```

## Key Insight: The Ergodicity Problem

This demonstrates the **ergodicity problem** in economics:
- **Expected value** suggests the game is profitable
- **Reality** shows most people lose money
- The difference comes from the multiplicative (not additive) nature of the game over time

### Resources

- **Quarto Markdown:** [quarto.org/docs/authoring/markdown-basics.html](https://quarto.org/docs/authoring/markdown-basics.html)
- **Quarto Documentation:** [quarto.org/docs](https://quarto.org/docs)
- **R for Data Science:** [r4ds.had.co.nz](https://r4ds.had.co.nz)
- **Python Data Science Handbook:** [jakevdp.github.io/PythonDataScienceHandbook](https://jakevdp.github.io/PythonDataScienceHandbook)

### Getting Started Tips

::: {.callout-note}
## üéØ Navy SEALs Motto

> "Slow is Smooth and Smooth is Fast"

*Take your time to understand the simulation mechanics, plan your approach carefully, and execute with precision. Rushing through this challenge will only lead to errors and confusion.*
:::

- **Browse [Essential Simulation Concepts](@sec-simulation-concepts):** This section will give you a good understanding of the concepts you need to know to complete the challenge.
- **Start Simple:** Begin with a single simulation to understand the mechanics
- **Document Everything:** Explain your reasoning and interpret your results
- **Forgetting to Set Seeds:** Always set random seeds for reproducible results
- **Total time to complete:** ~3-4 hours for the 100% grade ‚è±Ô∏è
- **Good luck, and remember simulation will steer you right even when intuition will steer you wrong!** üé≤

::: {.callout-warning}
## üíæ Important: Save Your Work Frequently!

**Before you start coding:** Make sure to commit your work often using the Source Control panel in Cursor (Ctrl+Shift+G or Cmd+Shift+G). This prevents the AI from overwriting your progress and ensures you don't lose your work.

**Commit after each major step:**

- After completing each simulation example
- After finishing each challenge question
- Before asking the AI for help with new code

**How to commit:**

1. Open Source Control panel (Ctrl+Shift+G)
2. Stage your changes (+ button)
3. Write a descriptive commit message
4. Click the checkmark to commit

*Remember: Frequent commits are your safety net!*
:::


## Essential Simulation Concepts üéØ {#sec-simulation-concepts}

Before diving into the challenge, let's review the key simulation concepts you'll need. These examples will prepare you for the investment game analysis.

### 1. Simple Simulation: Coin Flip Game

Let's start with a basic coin flip simulation to understand the mechanics:

#### Generative DAG Model for the Simple Coin Flip Game

```{python}
#| echo: false
#| include: false
#| eval: false
#| python.reticulate: false
import daft

# Create the DAG for simple coin flip game
simpleCoinDAG = daft.PGM(dpi=150, alternate_style="outer")

# Coin flip (stochastic node)
simpleCoinDAG.add_node("X", "Coin Flip\n$X \\sim \\text{Bernoulli}(0.5)$", x=1, y=1, aspect=4,
                      plot_params={'facecolor': 'aliceblue'})

# Winnings (deterministic node)
simpleCoinDAG.add_node("W", "Winnings\n$W = 100$ if $X = 1$ else $-100$", x=1, y=0, aspect=5.4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edge showing the relationship
simpleCoinDAG.add_edge("X", "W")
```

```{python}
#| label: fig-simple-coin-dag
#| fig-cap: Generative DAG model for the simple coin flip game showing the relationship between coin flip outcome and winnings
#| echo: false
#| eval: false
#| python.reticulate: false
simpleCoinDAG.show()
```

**Key Difference from Investment Game:** Unlike the investment game DAG (@fig-investment-dag) which models wealth evolution over multiple time periods with multiplicative changes, this simple coin flip DAG represents a single-period game with additive winnings. The investment game shows how wealth compounds over time ($W_t = 1.5 \times W_{t-1}$ or $W_t = 0.6 \times W_{t-1}$), while this simple game shows fixed winnings ($W = +100$ or $W = -100$) based on a single coin flip outcome.

::: {.panel-tabset}

### R

```{r}
#| label: simple-sim-r
#| fig-cap: R simulation of coin flip game
#| echo: false
#| include: false

suppressPackageStartupMessages(library(tidyverse))

# Set seed for reproducibility
set.seed(123)

# Number of simulations
n_sims <- 10

# Create simulation data
sim_data <- tibble(
  sim_num = 1:n_sims,
  coin_flip = rbinom(n = n_sims, size = 1, prob = 0.5)
) %>%
  mutate(
    winnings = if_else(coin_flip == 1, 100, -100)
  )

# Display results
sim_data
```

### Python

```{python}
#| label: simple-sim-python
#| fig-cap: Python simulation of coin flip game
#| echo: false
#| include: false
#| eval: false
#| python.reticulate: false

import numpy as np
import pandas as pd

# Set seed for reproducibility
np.random.seed(123)

# Number of simulations
n_sims = 10

# Step 1: Draw coin flips (stochastic node)
X = np.random.binomial(n=1, p=0.5, size=n_sims)

# Step 2: Compute winnings (deterministic node)
W = np.where(X == 1, 100, -100)

# Combine into data frame
sim_data = pd.DataFrame({
    'sim_num': range(1, n_sims + 1),
    'coin_flip': X,
    'winnings': W
})

# Display results
sim_data
```

:::

### 2. Time-Series Simulation: Account Balance Over Time

Now let's simulate how an account balance changes over multiple periods:

#### Generative DAG Model for Time-Series Account Balance

```{python}
#| echo: false
#| include: false
#| eval: false
#| python.reticulate: false
import daft

# Create the DAG for time-series simulation
timeSeriesDAG = daft.PGM(dpi=150, alternate_style="outer")

# Initial balance (deterministic)
timeSeriesDAG.add_node("B0", "Initial Balance\n$B_0 = 1000$", x=2, y=2.5, aspect=5.4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes
timeSeriesDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=-3, y=1, aspect=4, scale=1.6,
                      plot_params={'facecolor': 'aliceblue'})
timeSeriesDAG.add_node("Bt", "Balance t\n$B_t = B_{t-1} + 100$ if $C_t = 1$\n$B_t = B_{t-1} - 100$ if $C_t = 0$", x=2, y=1, scale=1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
timeSeriesDAG.add_edge("B0", "Bt")
timeSeriesDAG.add_edge("Ct", "Bt")

# Add plate around time-dependent nodes
timeSeriesDAG.add_plate([-5, 0.5, 9, 1.0], label="t = 1, ..., T", shift=-0.1)
```

```{python}
#| label: fig-timeseries-dag
#| fig-cap: Generative DAG model for time-series account balance simulation showing how balance evolves sequentially over multiple periods
#| echo: false
#| eval: false
#| python.reticulate: false
timeSeriesDAG.show()
```

**Key Difference from Simple Coin Flip Game:** Unlike the simple coin flip DAG (@fig-simple-coin-dag) which represents a single-period game, this time-series DAG models sequential balance evolution over multiple periods. Each period's balance depends on the previous period's balance plus the current coin flip outcome. The simple game shows independent winnings per flip, while this model shows cumulative balance changes where $B_t = B_{t-1} + \Delta_t$ and $\Delta_t = +100$ or $-100$ based on the coin flip.

::: {.panel-tabset}

### R

```{r}
#| label: timeseries-sim-r
#| fig-cap: R time-series simulation of account balance
#| echo: false
#| include: false

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(456)

# Parameters
initial_balance <- 1000
n_periods <- 10
n_sims <- 1  # Start with one simulation

# Simulate one path
simulate_path <- function(initial, periods) {
  balance <- initial
  path <- numeric(periods + 1)
  path[1] <- initial
  
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance + 100
    } else {
      balance <- balance - 100
    }
    path[i + 1] <- balance
  }
  
  return(path)
}

# Run simulation
time_series_data <- tibble(
  period = 0:n_periods,
  balance = simulate_path(initial_balance, n_periods)
)

# Create time series plot
ggplot(time_series_data, aes(x = period, y = balance)) +
  geom_line(color = "cadetblue", linewidth = 1.2) +
  geom_point(color = "darkblue", size = 2) +
  labs(
    title = "Account Balance Over Time",
    subtitle = "Single Simulation Path",
    x = "Period",
    y = "Account Balance ($)",
    caption = "Heads: +$100$, Tails: -$100$"
  ) +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Show the data
time_series_data
```

### Python

```{python}
#| label: timeseries-sim-python
#| fig-cap: Python time-series simulation of account balance
#| echo: false
#| include: false
#| eval: false
#| python.reticulate: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(456)

# Parameters
initial_balance = 1000
n_periods = 10
n_sims = 1  # Start with one simulation

# Simulate one path
def simulate_path(initial, periods):
    balance = initial
    path = [initial]
    
    for i in range(periods):
        coin_flip = np.random.binomial(1, 0.5)
        if coin_flip == 1:
            balance = balance + 100  # $100 gain
        else:
            balance = balance - 100  # $100 loss
        path.append(balance)
    
    return path

# Run simulation
time_series_data = pd.DataFrame({
    'period': range(n_periods + 1),
    'balance': simulate_path(initial_balance, n_periods)
})

# Create time series plot
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(time_series_data['period'], time_series_data['balance'], 
        color='cadetblue', linewidth=2, marker='o', markersize=6)
ax.set_title('Account Balance Over Time\nSingle Simulation Path', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Period', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.grid(True, alpha=0.3)
ax.set_ylim(0, max(time_series_data['balance']) * 1.1)

# Format y-axis as currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Show the data
print("Time Series Data:")
print(time_series_data)
```

:::

### 3. Probability Distribution: Final Balance Distribution

Let's see what the distribution of final balances looks like across many simulations:

::: {.panel-tabset}

### R

```{r}
#| label: distribution-sim-r
#| fig-cap: R probability distribution of final balances
#| echo: false
#| include: false

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(789)

# Parameters
initial_balance <- 1000
n_periods <- 10
n_sims <- 100  # Multiple simulations

# Simulate multiple paths
simulate_final_balance <- function(initial, periods) {
  balance <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance + 100  # $100 gain
    } else {
      balance <- balance - 100  # $100 loss
    }
  }
  return(balance)
}

# Run multiple simulations
final_balances <- replicate(n_sims, simulate_final_balance(initial_balance, n_periods))

# Create data frame
distribution_data <- tibble(
  sim_num = 1:n_sims,
  final_balance = final_balances
)

# Create histogram
ggplot(distribution_data, aes(x = final_balance)) +
  geom_histogram(bins = 20, fill = "plum", alpha = 0.8, color = "black") +
  geom_vline(xintercept = initial_balance, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Distribution of Final Account Balances",
    subtitle = paste("100 Simulations,", n_periods, "Periods Each"),
    x = "Final Balance ($)",
    y = "Frequency",
    caption = "Red line shows initial balance ($1,000)"
  ) +
  scale_x_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Summary statistics
summary_stats <- distribution_data %>%
  summarise(
    mean_balance = mean(final_balance),
    median_balance = median(final_balance),
    prob_above_initial = mean(final_balance > initial_balance)
  )

print("Summary Statistics:")
summary_stats
```

### Python

```{python}
#| label: distribution-sim-python
#| fig-cap: Python probability distribution of final balances
#| echo: false
#| include: false
#| eval: false
#| python.reticulate: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(789)

# Parameters
initial_balance = 1000
n_periods = 10
n_sims = 100  # Multiple simulations

# Simulate multiple paths
def simulate_final_balance(initial, periods):
    balance = initial
    for i in range(periods):
        coin_flip = np.random.binomial(1, 0.5)
        if coin_flip == 1:
            balance = balance + 100  # $100 gain
        else:
            balance = balance - 100  # $100 loss
    return balance

# Run multiple simulations
final_balances = [simulate_final_balance(initial_balance, n_periods) for _ in range(n_sims)]

# Create data frame
distribution_data = pd.DataFrame({
    'sim_num': range(1, n_sims + 1),
    'final_balance': final_balances
})

# Create histogram
fig, ax = plt.subplots(figsize=(10, 6))
ax.hist(distribution_data['final_balance'], bins=20, color='plum', alpha=0.8, edgecolor='black')
ax.axvline(initial_balance, color='red', linestyle='--', linewidth=2, label='Initial Balance')
ax.set_title(f'Distribution of Final Account Balances\n100 Simulations, {n_periods} Periods Each', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Final Balance ($)', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
ax.legend()
ax.grid(True, alpha=0.3)

# Format x-axis as currency
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Summary statistics
mean_balance = distribution_data['final_balance'].mean()
median_balance = distribution_data['final_balance'].median()
prob_above_initial = (distribution_data['final_balance'] > initial_balance).mean()

print("Summary Statistics:")
print(f"Mean balance: ${mean_balance:,.2f}")
print(f"Median balance: ${median_balance:,.2f}")
print(f"Probability above initial: {prob_above_initial:.3f}")
```

:::